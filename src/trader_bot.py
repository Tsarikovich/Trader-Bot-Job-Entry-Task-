import random
import time
import json
import os
from Order import Order
from db import collection
from logger import logger


class TraderBot:
    conditions = {
        "buy": {
            "success": lambda current_price, order: current_price <= order.price,
            "fail": lambda current_price, order, gap, gap_ignore: current_price >= order.price + gap + gap_ignore
        },
        "sell": {
            'success': lambda current_price, order: current_price >= order.price,
            'fail': lambda current_price, order, gap, gap_ignore: current_price <= order.price - gap - gap_ignore
        },
    }

    price_generator_bounds = (10, 110)  # min and max price generated by "stock"

    def __init__(self):
        with open(os.environ['PATH_TO_BOT_CONFIG_FILE'], 'r') as file:
            self.__config_data = json.loads(file.read())

    def trade_polling(self):
        """
            Main algorithm implementation.
            Buying and selling crypto according to config_data params.
        """

        while True:
            logger.info(f'New round started')

            buy_request_response = self.create_order(operation="buy")
            if buy_request_response['status'] == "Ok":

                order = buy_request_response['order']
                is_succeeded_buy = self.wait_till_conditions(order, "buy")
                if is_succeeded_buy:
                    self.selling()
                else:
                    self.cancel_order(order)

    def selling(self):
        """
            Part 3 and 4 of algorithm description
        """

        while True:
            logger.info(f'Selling started')

            sell_request_response = self.create_order(operation="sell")

            if sell_request_response['status'] == "Ok":

                order = sell_request_response['order']
                is_succeeded_sell = self.wait_till_conditions(order, "sell")

                if is_succeeded_sell:
                    logger.info(f"Order sold\n"
                                f'order id = {order.id}, order price = {order.price}')
                    return
                else:
                    self.cancel_order(order)

    def create_order(self, operation: str) -> dict:
        """
            Creating and posting order
            :return status "ok" and order if succeeded or "Failed"
        """

        order = self.generate_order(operation=operation)
        response = self.post_order(order, credentials=(self.__config_data['exchange']['client_id'],
                                                       self.__config_data['exchange']['client_secret']))

        if response['status'] == "Ok":
            logger.info(f'Created order=\n{order.__dict__}')
            collection.insert_one(order.__dict__)
            return {"status": "Ok", "order": order}

        return {"status": "Failed"}

    def generate_order(self, operation: str) -> Order:
        """
           Generating order relying on operation type
           :return Order
       """

        current_price = self.get_current_price()

        if operation == "buy":
            price = (current_price - self.__config_data['robot']['gap']) / 2
        else:
            price = (current_price + self.__config_data['robot']['gap'])

        order = Order(price, operation)
        return order

    def wait_till_conditions(self, order, operation) -> bool:
        """
              Just implementation of waiting till we need to cancel [BUY/SELL] order or just go forward
              :return True if the deal is succeeded or False if we need to cancel order
        """
        logger.info(f'Waiting till success/fail for {operation} operation')

        condition_success = TraderBot.conditions[operation]['success']
        condition_fail = TraderBot.conditions[operation]['fail']

        while True:
            current_price = self.get_current_price()

            if condition_success(current_price, order):
                return True

            if condition_fail(current_price, order, self.__config_data['robot']['gap'],
                              self.__config_data['robot']['gap_ignore']):
                return False

    @staticmethod
    def get_current_price() -> int:

        time.sleep(3)
        price = random.randint(TraderBot.price_generator_bounds[0], TraderBot.price_generator_bounds[1])
        logger.info(f'Current price request. Price={price}')

        return price

    @staticmethod
    def post_order(order: Order, credentials: tuple) -> dict:

        time.sleep(3)

        return {"status": "Ok"}

    @staticmethod
    def cancel_order(order):
        logger.info(f'Cancelling order:\n'
                    f'order id = {order.id}, order price = {order.price}')

        collection.delete_one({'id': order.id})
        time.sleep(2)
